# Redis

[toc]

## 数据类型

| 类型                | 简介                                                   | 特性                                                         | 场景                                                         |
| :------------------ | :----------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| String 字符串       | 二进制安全                                             | 可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512M | ---                                                          |
| Hash 字典           | 键值对集合,即编程语言中的Map类型                       | 适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值（Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去） | 存储、读取、修改用户属性                                     |
| List 列表           | 链表(双向链表)                                         | 增删快,提供了操作某一段元素的API                             | 1. 最新消息排行等功能(比如朋友圈的时间线) 2. 消息队列        |
| Set 集合            | 哈希表实现,元素不重复                                  | 1. 添加、删除,查找的复杂度都是O(1) 2. 为集合提供了求交集、并集、差集等操作 | 1. 共同好友 2. 利用唯一性,统计访问网站的所有独立ip 3. 好友推荐时，根据tag求交集，大于某个阈值就可以推荐 |
| Sorted Set 有序集合 | 将Set中的元素增加一个权重参数score,元素按score有序排列 | 数据插入集合时，已经进行天然排序                             | 1. 排行榜 2. 带权重的消息队列                                |

## Hash 字典

### HSCAN

```shell
HSCAN key cursor [MATCH pattern] [COUNT count]
```

- **cursor**：`HSCAN`命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为`HSCAN`命令的游标参数， 以此来延续之前的迭代过程。当`SCAN`命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。

- **COUNT**：`SCAN`命令以及其衍生命令并不保证每一轮迭代返回的元素数量，但是可以使用`COUNT`属性凭经验调整`SCAN`命令的行为。`COUNT`指定每次调用应该完成遍历的元素的数量，以便于遍历集合，**「本质只是一个提示值」**（`just a hint`，`hint`意思为暗示）。[解惑：Redis的HSCAN命令中COUNT参数的"失效"场景](https://blog.csdn.net/zjcsuct/article/details/108138876)

  - `COUNT`默认值为 10。
  - 当遍历的目标`Set`、`Hash`、`Sorted Set`或者`Key`空间足够大可以使用一个哈希表表示并且不使用`MATCH`属性的前提下，`Redis`服务端会返回`COUNT`或者比`COUNT`大的遍历元素结果集合。

  - 当遍历只包含`Integer`值的`Set`集合（也称为`intsets`），或者`ziplists`类型编码的`Hash`或者`Sorted Set`集合（说明这些集合里面的元素占用的空间足够小），那么`SCAN`命令会返回集合中的所有元素，直接忽略`COUNT`属性。

  - 虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用`COUNT`选项， 对命令的行为进行一定程度上的调整。 基本上，`COUNT`选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。

- **MATCH**：和`KEYS`命令一样， 增量式迭代命令也可以通过提供一个glob风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定`MATCH`参数来实现。

**返回值**

返回的每个元素都是一个元组，每一个元组元素由一个字段(field) 和值（value）组成。

**示例**

```shell
127.0.0.1:6379> FLUSHALL
OK

127.0.0.1:6379> HMSET site twle "twle.cn" bing "bing.com" qq "qq.com" baidu "baidu.com"
(integer) 4

127.0.0.1:6379> HSCAN site 0 match "t*"
1) "0"
2) 1) "twle"
   2) "twle.cn"
```


## SortedSet 有序集合

### ZADD

```shell
ZADD key [NX|XX] [CH] [INCR] score member [score member ...]
```

`ZADD`命令在`key`后面分数/成员（score/member）对前面支持一些参数，他们是：

- **XX**：仅仅更新存在的成员，不添加新成员。
- **NX**：不更新存在的成员。只添加新成员。
- **CH**：修改返回值为发生变化的成员总数，原始是返回新添加成员的总数 (CH 是 *changed* 的意思)。更改的元素是**新添加的成员**，已经存在的成员**更新分数**。 所以在命令中指定的成员有相同的分数将不被计算在内。注：在通常情况下，`ZADD`返回值只计算新添加成员的数量。
- **INCR**：当`ZADD`指定这个选项时，成员的操作就等同`ZINCRBY`命令，对成员的分数进行递增操作。

 在Redis 2.4以前，命令只能添加或者更新一个成员。

**返回值**

**Integer reply**

包括添加到有序集合的成员数量，不包括已经存在更新分数的成员。

如果指定`INCR`参数, 返回将会变成bulk-string-reply ：成员的新分数（双精度的浮点型数字）字符串。

**示例**

```shell
redis> ZADD myzset 1 "one"
(integer) 1
redis> ZADD myzset 1 "uno"
(integer) 1
redis> ZADD myzset 2 "two" 3 "three"
(integer) 2
redis> ZRANGE myzset 0 -1 WITHSCORES
1) "one"
2) "1"
3) "uno"
4) "1"
5) "two"
6) "2"
7) "three"
8) "3"
redis> 
```

[ZADD用法-阿里云开-发者社区](https://developer.aliyun.com/article/504008)

### ZCARD

