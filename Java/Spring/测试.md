# Mockito

## mock 和 spy

在 **Mockito** 中，`mock` 和 `spy` 是两种常用的对象创建方式，它们的行为有所不同，理解这两者的区别非常重要。

### 1. **`mock`（模拟对象）**
- **定义**：`mock` 创建一个完全虚拟的对象，它不会调用真实的方法。所有的方法都会返回默认值（如 `null`、`0`、`false` 等），除非显式设置返回值。
- **用途**：适用于你不关心被模拟对象的内部实现或行为，只关心它的接口和交互。
- **行为**：所有方法默认返回 `null` 或对应类型的默认值，除非你手动设置返回值。
#### 示例：
```java
import static org.mockito.Mockito.*;
import org.junit.Test;
import java.util.List;

public class MockitoMockTest {

    @Test
    public void testMock() {
        // 创建一个 mock 对象
        List<String> mockList = mock(List.class);

        // 通过 when() 来定义方法返回的结果
        when(mockList.size()).thenReturn(10);

        // 调用 mock 对象的方法
        System.out.println(mockList.size());  // 输出 10
        System.out.println(mockList.get(0));  // 输出 null，因为 mock 对象默认返回 null
    }
}
```

**特点：**
- **不调用实际实现**：所有方法调用都是空的（不执行实际方法体）。
- **灵活性强**：可以通过 `when()`、`verify()` 等设置模拟行为和验证交互。

### 2. **`spy`（间谍对象）**
- **定义**：`spy` 是对一个真实对象的部分模拟，既可以保留对象的真实行为，也可以对某些方法进行模拟（改变行为）。`spy` 是对现有对象的包装，允许你选择性地模拟某些方法，其他方法继续使用原来的实现。
- **用途**：适用于你需要部分模拟对象，但又不想完全放弃真实实现的场景。比如，模拟某些方法，而不影响其他方法的行为。
- **行为**：对 `spy` 对象，除非你明确模拟某些方法，否则其他方法会调用真实的实现。

#### 示例：
```java
import static org.mockito.Mockito.*;
import org.junit.Test;
import java.util.List;
import java.util.ArrayList;

public class MockitoSpyTest {

    @Test
    public void testSpy() {
        // 创建一个真实的 ArrayList 对象
        List<String> realList = new ArrayList<>();

        // 使用 spy 包装真实对象
        List<String> spyList = spy(realList);

        // 调用真实的行为
        spyList.add("Hello");
        System.out.println(spyList.size());  // 输出 1，真实调用了 add() 方法

        // 使用 when() 来模拟特定方法的行为
        when(spyList.size()).thenReturn(10);
        System.out.println(spyList.size());  // 输出 10，因为我们模拟了 size() 方法

        // 其他方法仍然会调用真实实现
        spyList.add("World");
        System.out.println(spyList.size());  // 输出 2，真实调用了 add() 方法
    }
}
```

**特点：**
- **部分模拟**：`spy` 会保留真实对象的行为，可以在某些方法上应用模拟（mocking），其他方法继续调用真实实现。
- **调用真实方法**：如果没有使用 `when()` 来模拟方法，`spy` 会调用真实对象的方法。

### 3. **关键区别**
| 特性         | `mock`                                     | `spy`                                        |
| ------------ | ------------------------------------------ | -------------------------------------------- |
| **对象行为** | 完全模拟对象，所有方法调用不会执行真实逻辑 | 对真实对象进行部分模拟，其他方法保持真实行为 |
| **默认行为** | 返回默认值：`null`、`0`、`false` 等        | 调用真实的方法，除非显式模拟某些方法         |
| **适用场景** | 当你不关心对象内部实现，只关注接口和交互时 | 当你想保留对象的部分行为，但模拟特定方法时   |
| **方法调用** | 不能调用真实方法，所有方法调用返回默认值   | 默认调用真实方法，可以选择模拟某些方法       |
| **创建方式** | `mock(Class<T> classToMock)`               | `spy(T realObject)`                          |

### 4. **使用场景**
- **使用 `mock`**：
  - 当你完全不关心对象的内部实现时，只关心方法调用和交互。
  - 比如，只需要测试某个对象的返回值和方法调用，而不需要关心方法的实际实现或副作用。
  
- **使用 `spy`**：
  - 当你需要部分模拟对象的方法，并且保留其他方法的真实行为时。
  - 比如，想要模拟某个方法的返回值（例如 `size()`），但不想改变该对象的其他行为（如 `add()`）。

### 5. **注意事项**
- 使用 `spy` 时，如果没有显式模拟某些方法，它会执行真实方法。如果你不希望调用真实方法，可以使用 `doReturn()` 或 `when()` 明确指定返回值。
  
#### 示例：`spy` 的一些限制
```java
import static org.mockito.Mockito.*;
import org.junit.Test;
import java.util.List;
import java.util.ArrayList;

public class MockitoSpyTest {

    @Test
    public void testSpy() {
        List<String> realList = new ArrayList<>();
        List<String> spyList = spy(realList);

        // spy 对象方法调用真实行为
        spyList.add("Hello");
        spyList.add("World");

        // 当调用真实方法时，spy 会调用实际方法
        System.out.println(spyList.size());  // 输出 2

        // 模拟某个方法的行为
        doReturn(100).when(spyList).size();
        System.out.println(spyList.size());  // 输出 100，模拟了 size 方法
    }
}
```

**总结**：
- `mock` 完全模拟对象，所有方法都是虚拟的，不调用真实实现。
- `spy` 保留真实对象的行为，可以选择性地模拟某些方法的行为。

## 构造器传参

在旧版本的 Mockito（1.x 及之前）中，标准的 Mockito 主要支持无参构造函数的模拟，并且对于有参数的构造函数，通常需要用 `PowerMockito` 或者 `Mockito` 的 `Answer` 来模拟构造过程。但在 **Mockito 2.x 之后**，Mockito 增加了对带参数构造函数的支持，具体是通过 `Mockito.withSettings().useConstructor()` 这个方法。

`Mockito.withSettings()` 和 `.useConstructor()` 是 Mockito 中的一个配置方法，用于在创建模拟对象时指定某些额外的配置选项，尤其是与对象的构造函数相关的配置。这个功能通常在模拟一个类的带参数构造函数时非常有用。

### `.useConstructor()` 的作用

`Mockito.withSettings().useConstructor()` 允许你在创建模拟对象时指定构造函数的参数，从而使得 Mockito 能够使用带有特定参数的构造函数来创建对象。它对于那些有复杂构造函数（带参数）的类尤其有用，可以让你控制对象的创建过程。

### 语法和示例

```java
import org.mockito.Mockito;
import org.junit.Test;

import static org.mockito.Mockito.*;

public class MockitoWithSettingsTest {

    @Test
    public void testUseConstructor() {
        // 使用 withSettings() 和 useConstructor() 来模拟带有参数构造函数的对象
        MyClass mockObject = Mockito.mock(MyClass.class, 
            Mockito.withSettings().useConstructor("arg1", 123));

        // 调用 mock 对象的行为
        System.out.println(mockObject.toString());  // 你可以根据需要进行进一步的验证和行为设定
    }
}
```

### `.useConstructor()` 传入的参数

- `.useConstructor()` 方法允许你为带参数的构造函数传入构造参数。在这个示例中，`MyClass` 是一个具有构造函数 `MyClass(String arg1, int arg2)` 的类。
- 你可以传递构造函数需要的参数（例如 `"arg1"` 和 `123`），Mockito 会使用这些参数来调用构造函数并创建对象。

### `withSettings()` 配置选项

`.withSettings()` 是 `Mockito.mock()` 方法的一部分，它允许你对模拟对象进行一些自定义设置，诸如：
- 设定特定的行为。
- 设置构造函数参数（如 `.useConstructor()`）。
- 配置其他行为选项（比如是否使用真实方法等）。

### 示例代码：模拟带参数构造函数的对象

假设我们有一个带参数构造函数的类 `MyClass`：

```java
public class MyClass {
    private String arg1;
    private int arg2;

    // 带参数构造函数
    public MyClass(String arg1, int arg2) {
        this.arg1 = arg1;
        this.arg2 = arg2;
    }

    public String toString() {
        return "MyClass: " + arg1 + ", " + arg2;
    }
}
```

现在，使用 Mockito 创建这个类的模拟对象，并指定构造函数的参数：

```java
import org.mockito.Mockito;
import org.junit.Test;
import static org.mockito.Mockito.*;

public class MockitoWithSettingsTest {

    @Test
    public void testUseConstructor() {
        // 使用 withSettings() 和 useConstructor() 来模拟带有参数构造函数的对象
        MyClass mockObject = Mockito.mock(MyClass.class, 
            Mockito.withSettings().useConstructor("Hello", 123));

        // 验证构造参数是否成功
        System.out.println(mockObject.toString());  // 输出 "MyClass: null, 0"
    }
}
```

### 解释：
- **`useConstructor("Hello", 123)`**：在这里，我们通过 `.useConstructor()` 指定了构造函数参数。`MyClass` 的构造函数会接收这两个参数 `"Hello"` 和 `123`，并用它们来初始化对象。
- **构造函数参数传递给模拟对象**：Mockito 会创建一个 `MyClass` 的模拟对象，并传递这两个参数。

### 注意：
- `Mockito.withSettings().useConstructor()` 主要用于创建带有特定构造函数参数的模拟对象。它只会影响如何创建对象，并不会自动模拟构造函数的内部行为。实际对象的行为依然可以通过 `Mockito.when()` 等方法来进一步设置。
- 如果类本身有复杂的行为，你可能还需要在模拟对象的其他方法上设置行为。

### 总结
`Mockito.withSettings().useConstructor()` 用于在创建模拟对象时指定带参数的构造函数。通过这种方式，你可以模拟那些需要传入构造参数的类，而不仅仅是通过无参构造函数来创建模拟对象。这使得你能够更加灵活地控制模拟对象的创建，特别是在涉及依赖注入或具有复杂构造函数的类时非常有用。